<!--- @file
  Appendix J Makefiles

  Copyright (c) 2008-2017, Intel Corporation. All rights reserved.<BR>

  Redistribution and use in source (original document form) and 'compiled'
  forms (converted to PDF, epub, HTML and other formats) with or without
  modification, are permitted provided that the following conditions are met:

  1) Redistributions of source code (original document form) must retain the
     above copyright notice, this list of conditions and the following
     disclaimer as the first lines of this file unmodified.

  2) Redistributions in compiled form (transformed to other DTDs, converted to
     PDF, epub, HTML and other formats) must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

  THIS DOCUMENTATION IS PROVIDED BY TIANOCORE PROJECT "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
  EVENT SHALL TIANOCORE PROJECT  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF
  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-->

# Appendix J Makefiles

This appendix describes the format of the Makefiles created by the EDK II build
system.

## J.1 NMAKE Module Makefile Format

The build system will generate a top level Makefile for each module in the
platform, using the target and tool chain as an identifier for the combination.
If multiple architectures are part of the platform build, there will be a
separate tree under the directory for each module that requires
multi-architecture builds.

#### Template

```
  # DO NOT EDIT
  # This file is auto-generated by build utility
  #
  # Module Name:
  #
  #   %s
  #
  # Abstract:
  #
  #   Auto-generated makefile for building modules, libraries or platform
  #

  #
  # Platform Macro Definition
  #
  PLATFORM_NAME         = ${platform_name}
  PLATFORM_GUID         = ${platform_guid}
  PLATFORM_VERSION      = ${platform_version}
  PLATFORM_RELATIVE_DIR = ${platform_relative_directory}
  PLATFORM_DIR          = $(WORKSPACE)${sep}${platform_relative_directory}
  PLATFORM_OUTPUT_DIR   = ${platform_output_directory}

  #
  # Module Macro Definition
  #
  MODULE_NAME           = ${module_name}
  MODULE_GUID           = ${module_guid}
  MODULE_VERSION        = ${module_version}
  MODULE_TYPE           = ${module_type}
  MODULE_FILE           = ${module_file}
  MODULE_FILE_BASE_NAME = ${module_file_base_name}
  BASE_NAME             = $(MODULE_NAME)
  MODULE_RELATIVE_DIR   = ${module_relative_directory}
  MODULE_DIR            = $(WORKSPACE)${sep}${module_relative_directory}

  MODULE_ENTRY_POINT    = ${module_entry_point}
  ARCH_ENTRY_POINT      = ${arch_entry_point}
  IMAGE_ENTRY_POINT     = ${image_entry_point}

  ${module_extra_defines}
  #
  # Build Configuration Macro Definition
  #
  ARCH          = ${arch}
  TOOLCHAIN     = ${toolchain_tag}
  TOOLCHAIN_TAG = ${toolchain_tag}
  TARGET        = ${build_target}

  #
  # Build Directory Macro Definition
  #
  # PLATFORM_BUILD_DIR = ${platform_build_directory}
  BUILD_DIR        = ${platform_build_directory}
  BIN_DIR          = $(BUILD_DIR)${sep}${architecture}
  LIB_DIR          = $(BIN_DIR)
  MODULE_BUILD_DIR = ${module_build_directory}
  OUTPUT_DIR       = ${module_output_directory}
  DEBUG_DIR        = ${module_debug_directory}
  DEST_DIR_OUTPUT  = $(OUTPUT_DIR)
  DEST_DIR_DEBUG   = $(DEBUG_DIR)

  #
  # Shell Command Macro
  #
  RD = rmdir /s /q
  RM = del /f /q
  MD = mkdir
  CP = copy /y
  MV = move /y

  #
  # Tools definitions specific to this module
  #
  ${module_tool_definitions}
```

**********
**Note:** `${module_tool_definitions}` individual lines that contain an
environment name followed by the equal sign, followed by a string. The
following two lines are an example.
**********

```
TIANO = TianoCompress
TIANO_GUID = A31280AD-481E-41B6-95E8-127F4C984779

MAKE_FILE = ${makefile_path}

#
# Build Macro
#
```

**********
**Note:** The value of ${macroname} is derived from the file types identified
in the `build_rule.txt` file, these are typically: `OBJECT_FILES` and
`STATIC_LIBRARY_FILES` a special macro name, `INC` is also emitted listing the
EDK II Include directories required from a module's dependent packages. The
`INC` list entry prepends the compiler's option character sequence to include
the directory in the search list.
**********

```
${macro_name} = \
\t$(OUTPUT_DIR)${sep}${filename} \\
```

**********
**Note:** The above line is duplicated for additional files, the "\\" is
removed from the last line if this list. A text file for each of these macro
sets (except `INC`) is generated in the module's `OUTPUT` directory.
**********

```
${macro_name}_LIST = $(OUTPUT_DIR)${sep}${macro_name}.lst

COMMON_DEPS = \
\t${common_dependency_file} \\
```

**********
**Note:** The above line is duplicated for all header files required by the
module (defined by the #include statements) and files included by header files
required by the module
**********

```ini
#
# Overridable Target Macro Definitions
#
FORCE_REBUILD = force_build
INIT_TARGET = init
PCH_TARGET =
BC_TARGET = $ {backward_compatible_target}
CODA_TARGET = $ {remaining_build_target} \\
```

**********
**Note:** The above line contains the name of the output .efi file generated by
the drivers or the .lib file generated by libraries. The backslash character is
added to allow extra lines after `$(CODE_TARGET)` is specified.
**********

```
#
# Default target, which will build dependent libraries in addition to
# source files
#

all: mbuild

#
# Target used when called from platform makefile, which will bypass
# the build of dependent libraries since the platform makefile builds
# all libraries first.
#

pbuild: $(INIT_TARGET) $(BC_TARGET) $(PCH_TARGET) $(CODA_TARGET)


#
# ModuleTarget
#

mbuild: $(INIT_TARGET) $(BC_TARGET) gen_libs $(PCH_TARGET)$(CODA_TARGET)

#
# Build Target used in multi-thread build mode, which will bypass the
# init and gen_libs targets
#

tbuild: $(BC_TARGET) $(PCH_TARGET) $(CODA_TARGET)

#
# Phony target which is used to force executing commands for a target
#

force_build:
\t-@

#
# Target to update the FD
#

fds: mbuild gen_fds

#
# Initialization target: print build information and create necessary directories
#
init: info dirs

info:
\t-@echo Building ... $(MODULE_DIR)${sep}$(MODULE_FILE) [$(ARCH)]

dirs:
\t-@-@if not exist $(DEBUG_DIR) $(MD) $(DEBUG_DIR)
\t-@if not exist $(OUTPUT_DIR) $(MD) $(OUTPUT_DIR)

strdefs:
\t-@$(CP) $(DEBUG_DIR)${ds}AutoGen.h \
     $(DEBUG_DIR)${ds}$(MODULE_NAME)StrDefs.h
```

**********
**Note:** The above two lines are not exact, as they will appear on the same
line in the generated Makefile without the "\" line extension character.
**********

```
#
# GenLibsTarget
#
gen_libs:
\t$@"$(MAKE)" $(MAKE_FLAGS) \
     -f ${dependent_library_build_directory}${sep}${makefile_name}
```

**********
**Note:** The above two lines are not exact, as they will appear on the same
line in the generated Makefile without the "\" line extension character. The
line is repeated for every library instance that the module requires to be
linked against.
**********

```
\t$@cd $(MODULE_BUILD_DIR)

#
# Build Flash Device Image
#
gen_fds:
\t@"$(MAKE)" $(MAKE_FLAGS) -f $(BUILD_DIR)${sep}${makefile_name} fds
\t@cd $(MODULE_BUILD_DIR)

#
# Individual Object Build Targets
#
${file_build_target}
```

**********
**Note:** The above line is repeated for each `CODA_TARGET` using the format from
the `build_rule.txt` file to build intermediate files.
**********

```
#
# clean all intermediate files
#
clean:
\tif exist $(OUTPUT_DIR) $(RD) $(OUTPUT_DIR)
\t$

#
# clean all generated files
#
cleanall:
\tif exist $(DEBUG_DIR) $(RD) $(DEBUG_DIR)
\tif exist $(OUTPUT_DIR) $(RD) $(OUTPUT_DIR)
\t$(RM) *.pdb *.idb > NUL 2>&1
\t$(RM) $(BIN_DIR)${sep}$(MODULE_NAME).efi

#
# clean all dependent libraries built
#
cleanlib:
\t${library_build_command} cleanall
```

**********
**Note:** The above `${library_build_command}` is repeated for every library
instance used to link against the driver or application module. It first tests
for the existence of the makefile and if it exists, runs the make command. If
the module is a library, the above lines are not emitted.
**********

```
\t@cd $(MODULE_BUILD_DIR)\n\n
```
